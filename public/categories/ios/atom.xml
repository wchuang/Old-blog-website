<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | @wchuang's Blog]]></title>
  <link href="http://blog.wchuang.me/categories/ios/atom.xml" rel="self"/>
  <link href="http://blog.wchuang.me/"/>
  <updated>2015-10-25T02:14:34+08:00</updated>
  <id>http://blog.wchuang.me/</id>
  <author>
    <name><![CDATA[WEI-CHENG HUANG]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Custom NSLog]]></title>
    <link href="http://blog.wchuang.me/post/2015/10/14/custom-nslog/"/>
    <updated>2015-10-14T01:21:14+08:00</updated>
    <id>http://blog.wchuang.me/post/2015/10/14/custom-nslog</id>
    <content type="html"><![CDATA[<pre><code>#ifdef DEBUG
#   define DLog(fmt, ...) NSLog((@"%s [Line %d] " fmt), __PRETTY_FUNCTION__, __LINE__, ##__VA_ARGS__);
#else
#   define DLog(...)
#endif

#define ALog(fmt, ...) NSLog((@"%s [Line %d] " fmt), __PRETTY_FUNCTION__, __LINE__, ##__VA_ARGS__);

#ifdef DEBUG
#   define ULog(fmt, ...)  { UIAlertView *alert = [[UIAlertView alloc] initWithTitle:[NSString stringWithFormat:@"%s\n [Line %d] ", __PRETTY_FUNCTION__, __LINE__] message:[NSString stringWithFormat:fmt, ##__VA_ARGS__]  delegate:nil cancelButtonTitle:@"Ok" otherButtonTitles:nil]; [alert show]; }
#else
#   define ULog(...)
#endif
</code></pre>

<p>加入以上的 code 到 .pch 檔。</p>

<p>這邊定義了三種不同的 log 方式</p>

<ul>
<li>DLog：相當於 NSLog，但它只有在 DEBUG 模式中才可以被使用。相較於 NSLog，自訂的 function 名稱及程式碼行數也會印出來。</li>
<li>ALog：等同 NSLog，function 名稱及程式碼行數也會印出來。</li>
<li>ULog：等於用 UIAlertView 印出 DLog。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Distribute an iOS Application OTA]]></title>
    <link href="http://blog.wchuang.me/post/2015/04/08/distribute-an-ios-application-ota/"/>
    <updated>2015-04-08T00:53:56+08:00</updated>
    <id>http://blog.wchuang.me/post/2015/04/08/distribute-an-ios-application-ota</id>
    <content type="html"><![CDATA[<p>簡單記錄如何建立給外部使用者或客戶測試的 AdHoc 版本</p>

<p>iOS app OTA (over the air)，</p>

<p>而如何產生憑證及 archive 出 AdHoc 就不再贅述了，網路也有很多資源。</p>

<ol>
<li><p>重要的是描述下載位置的 HTML、描述 app 的 plist 檔案以及 app 的 .ipa 檔案，找台伺服器來存放它們吧！這邊推薦使用 Dropbox 方便又好用，當然你也可以用自家 server 或其它 web storage services。</p></li>
<li><p>.ipa 檔：AdHoc 出 .ipa 檔案，並上傳到 Dropbox 底下，點選分享後，會拿到一個分享連結，如 <a href="https://www.dropbox.com/s/ooxxaabbcc/ForTestingApp.ipa?dl=0">https://www.dropbox.com/s/ooxxaabbcc/ForTestingApp.ipa?dl=0</a> ，把 www.dropbox.com 改成 dl.dropboxusercontent.com 及 ?dl=0 拿掉，會變成 &ndash;> <a href="https://dl.dropboxusercontent.com/s/ooxxaabbcc/ForTestingApp.ipa">https://dl.dropboxusercontent.com/s/ooxxaabbcc/ForTestingApp.ipa</a> 。</p></li>
<li><p>plist 檔：加入一個 Array 的 key，名稱取為 assets，負責描述 .ipa、app icon 兩張（57 * 57）及 (512 * 512) 的分享連結路徑 (與上述 .ipa 檔案ㄧ樣，需放在 dropbox 中，並開啟分享取得連結)，如果不放圖片的話，下載中就看不到 app 的 icon 囉。再加入一個 Dictionary 的 key，名稱取為 metadata，描述 app 相關資訊，如 bundle-identifier、title 或 subtitle 等等。最後一樣開啟分享取得連結。</p></li>
<li><p>HTML 檔：最後是 HTML，拿來記錄上述 plist 檔的分享位置，並做個畫面呈現給使用者點選下載，可以簡單放上下列程式。</p>

<pre><code> &lt;a href="itms-services://?action=download-manifest&amp;url=
 https://dl.dropboxusercontent.com/s/ooxxaabbcc/ForTestingApp.plist"&gt;
 Install this awesome app!&lt;/a&gt;
</code></pre></li>
</ol>


<p>完成後你就可以把 HTML 的連結給你的朋友或客戶測試囉，不過要記得把手機的 UDID 加進去 Provisioning Profile。</p>

<p>以上，有不清楚的地方歡迎指教 :p</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[UIView viewWithTag:]]]></title>
    <link href="http://blog.wchuang.me/post/2014/11/11/uiview-viewwithtag/"/>
    <updated>2014-11-11T01:46:01+08:00</updated>
    <id>http://blog.wchuang.me/post/2014/11/11/uiview-viewwithtag</id>
    <content type="html"><![CDATA[<p>這篇關於使用 [UIView viewWithTag:] 的文章，雖然已是兩年前的，但在下認為文章內所提及的觀念與用法還是很值得與大家分享。</p>

<p>UIView 有個 tag 屬性以及相對應的方法 -viewWithTag:，讓我們可以輕易的存取特定的 view，而不需要額外的 reference。</p>

<p>這邊作者分享了幾個使用上常見的問題：</p>

<ul>
<li><p>不要使用 tags 來儲存資料，例如：陣列存取物件的索引 (index)&hellip;，因為這是一件容易造成後續維護者難以理解你的 code 的一件事&hellip;底下是一個使用 button 來呈現圖片縮圖的例子，為了記得哪個按鈕被按到以及要呈現哪個對應於 array 中的圖片索引，所以利用 tag 來記錄。<del>(但其實還滿容易這麼幹的啊&hellip;在下也常這麼做，要好好檢討了orz)</del></p>

<pre><code>  - (void)configureThumbnailButton:(UIButton *)thumbnailButton 
                          forPhoto:(NSUInteger)photoIndex {
      // ...
      thumbnailButton.tag = 1 + photoIndex;
      // ...
  }

  - (void)thumbnailButtonTapped:(id)sender {
      UIButton *thumbnailButton = sender;
      NSUInteger photoIndex = thumbnailButton.tag - 1;
      id selectedPhoto = [self.photoArray objectAtIndex:photoIndex];
      [self showPhoto:selectedPhoto];
  }
</code></pre></li>
<li><p>存取 view 額外資料的幾個比較正確的方式：</p>

<p>我們來探討一下為什麼會寫出上述例子的程式碼，其實也只是想要知道 button 對應的 index，或是 button 真正對應的圖片縮圖，此時更適合的方式應該是另外做一個 custom subClass 來儲存這些有用的額外資料，延續上述例子，應該可以這麼做：</p>

<pre><code>  @interface PhotoThumbnailButton : UIButton

  @property (nonatomic, assign) NSInteger photoIndex;
  // OR
  @property (nonatomic, strong) Photo *photo;

  @end
</code></pre>

<p>這時候你會說，如果每次都要這樣也太麻煩了吧！的確，每次都要建個 subClass 有時可能不符合實際情況，底下也提供一個用法：Associated references。</p></li>
<li><p><a href="http://goo.gl/6fM6Kq">Associated references</a>：提供了 objc_getAssociatedObject 以及 objc_setAssociatedObject 等方法，可以利用特定的 key 及 policy 存取特定的 obejct。如：</p>

<pre><code>  #import &lt;objc/runtime.h&gt;

  static char kThumbnailButtonAssociatedPhotoKey;

  // ...

  - (void)setAssociatedPhoto:(Photo *)associatedPhoto
          forThumbnailButton:(UIButton *)thumbnailButton {
      objc_setAssociatedObject(thumbnailButton,
                               &amp;kThumbnailButtonAssociatedPhotoKey,
                               associatedPhoto,
                               OBJC_ASSOCIATION_RETAIN_NONATOMIC);
  }

  - (Photo *)associatedPhotoForThumbnailButton:(UIButton *)thumbnailButton {
      return objc_getAssociatedObject(thumbnailButton,
                                       &amp;kThumbnailButtonAssociatedPhotoKey);
  }
</code></pre>

<p>存取時，</p>

<pre><code>  - (void)configureThumbnailButtonForPhoto:(Photo *)photo {
      // ...
      [self setAssociatedPhoto:photo forThumbnailButton:thumbnailButton];
      // ...
  }

  - (void)thumbnailButtonTapped {
      Photo *photo = [self associatedPhotoForThumbnailButton:thumbnailButton];
      // ...
  }
</code></pre>

<p>真的是很酷啊&hellip; 可是，如果只是想要快速直接的知道是哪一個 view，這樣的方式還是不夠直覺&hellip;所以，有些情況下，你還是會想直接利用 UIView&rsquo;s tag 存取，但重點是請遵循 UIView&rsquo;s tag 是 UIView 的唯一識別、可讀性以及易維護性的觀念，而使用 #define 或 enum value 來設定 tags，在你之後的開發者會很感謝你的..XD，例如：</p>

<pre><code>  enum MyViewTags {
      kTitleLabelTag = 1,
      kSendButtonTag,
      kSomeOtherViewTag
  };

  // ...

  if (sender.tag == kSendButtonTag) {
      // ...
  }
</code></pre></li>
<li><p>結論：</p>

<ul>
<li>不要使用 tags 來儲存資料 &ndash;> use sub-class or associated references resolving this.</li>
<li>多利用 public properties of sub-class for getting references of subviews.</li>
<li>If you do use tags, do not use magic numbers. Use named constants.</li>
</ul>
</li>
<li><p><a href="http://goo.gl/0xHqWt">Ref.</a></p></li>
</ul>

]]></content>
  </entry>
  
</feed>
